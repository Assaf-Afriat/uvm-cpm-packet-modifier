Reported By,Date Logged,Type,Description,Spec/RTL Location,Severity,Expected Behavior (Student),Actual Behavior (Spec/RTL),Proposed Fix / Clarification,Status,Version Observed
Assaf Afriat,2026-02-01,Spec Ambiguity,ROT_AMT value undefined - spec mentions rotate_left(payload_in ROT_AMT) but never defines ROT_AMT value,Page 11 Section 7.2 Mode-Dependent Behavior,Medium,ROT_AMT should be explicitly defined (e.g. 4 bits),Spec says ROT_AMT but value is undefined,Add explicit statement: ROT_AMT = 4 (rotate left by 4 bits),Resolved - Clarified in Spec v1.1,1.0
Assaf Afriat,2026-02-01,Spec Ambiguity,Ordering contradiction - Spec says No reordering permitted but different modes have different latencies (0/1/2 cycles) causing packets to arrive out of order,Page 12 Section 7.3 Ordering Guarantees,High,Clarify whether latency-based reordering is considered reordering or not,PASS mode (0 cycles) and ADD mode (2 cycles) will cause out-of-order arrival,Clarify: Ordering refers to acceptance order not output order OR explicitly state packets maintain input acceptance order at output,Resolved - Spec v1.1 Section 6.2 states CPM preserves strict packet ordering between input and output; Section 7.2 confirms config sampled at in_fire; DUT maintains FIFO ordering regardless of mode latency differences,1.0
Assaf Afriat,2026-02-01,Spec Ambiguity,Counter overflow behavior undefined - What happens when 32-bit counters overflow?,Page 20 Section 10.8 Counter Registers,Low,Counters should wrap around on overflow (standard behavior),Spec does not define overflow behavior,Add statement: Counters wrap around on overflow (implementation-defined),Resolved - RTL confirms standard 32-bit wrap-around behavior on overflow; spec v1.1 Section 1.2 states undefined behaviors are implementation-defined,1.0
Assaf Afriat,2026-02-01,Spec Ambiguity,ENABLE deassertion behavior for in-flight packets - What happens to packets already accepted when ENABLE goes low?,Page 19 Section 10.8 CTRL Register,Medium,In-flight packets should complete processing before stopping,Spec does not define behavior for in-flight packets,Clarify: In-flight packets complete processing OR are flushed when ENABLE deasserted,Resolved - RTL confirms in-flight packets are flushed when ENABLE deasserted (s0.v/s1.v cleared); spec v1.1 Section 1.2 states this is implementation-defined,1.0
Assaf Afriat,2026-02-01,Spec Ambiguity,SOFT_RST scope unclear - Does soft reset clear only counters/state or also flush in-flight packets in pipeline?,Page 19 Section 10.8 CTRL Register,Medium,SOFT_RST should clear counters AND flush pipeline,Spec says clears counters and internal state but unclear about pipeline,Clarify: SOFT_RST clears counters and flushes all pipeline stages,Partially Resolved - Spec v1.1 says clears counters and internal state (interpreted as including pipeline),1.1
Assaf Afriat,2026-02-01,Missing Requirement,in_ready behavior when disabled - Should in_ready be deasserted when ENABLE=0?,Page 4 Section 2 Reset behavior,Low,in_ready should be 0 when ENABLE=0 (no packets accepted),Spec says No input packets accepted but does not specify in_ready value,Add: When ENABLE=0 in_ready shall be deasserted,Resolved - RTL confirms in_ready = ctrl_enable && !buffer_full; in_ready is deasserted when ENABLE=0,1.0
Assaf Afriat,2026-02-01,Open Question,Counter invariant timing - When is the invariant COUNT_OUT + DROPPED_COUNT == COUNT_IN guaranteed to hold?,Page 20 Section 10.8 Counter Registers,Medium,Invariant should hold when pipeline is empty (BUSY=0),Spec says when stable but does not define stable condition,Clarify: Invariant holds when STATUS.BUSY=0 (pipeline empty),Resolved - Spec v1.1 Section 10.7 defines BUSY as asserted when packets are in-flight; invariant holds when BUSY=0,1.1
Assaf Afriat,2026-02-01,Other,DUT verification passed - All 195 packets matched across all 4 modes. All 7 assertions passed. No RTL bugs found.,N/A,N/A,N/A,DUT behavior matches specification interpretation,N/A,Resolved,1.0
Assaf Afriat,2026-02-02,RTL Bug,COUNT_OUT counter increments on out_valid instead of out_fire causing multiple counts per packet during backpressure,cpm_rtl.sv line 221-223,High,COUNT_OUT should increment once per packet output (on out_fire handshake),COUNT_OUT increments every cycle out_valid is high - if out_ready is low for N cycles COUNT_OUT increments N times for same packet,Change line 221 from 'if (out_valid)' to 'if (out_fire)' to count only completed handshakes,Fixed in RTL - COUNT_OUT now increments on out_fire (line 287-289),1.1
Assaf Afriat,2026-02-04,RTL Bug,Output signals change while out_valid=1 and out_ready=0 (violates stall stability rule),Spec Page 10 Section 6.3 Stability Rules,High,out_id/out_opcode/out_payload must remain stable while out_ready=0 and out_valid=1,Observed SVA failures: output fields change during stall,Hold output fields stable until out_fire completes,Fixed in RTL - s0 slot only updates on out_fire; outputs derived from s0 remain stable during stall,1.1
Assaf Afriat,2026-02-06,Spec/RTL Mismatch,ROT_AMT is specified as a configurable parameter for ROT mode but is hardcoded in RTL,Spec Section 7.2 Mode-Dependent Behavior (rotate_left(payload_in, ROT_AMT)) and cpm_rtl.sv localparam ROT_AMT=4,Medium,ROT_AMT should be configurable via a register field (e.g., in PARAMS) and sampled at in_fire,RTL uses constant ROT_AMT=4 and no register field exists,Add ROT_AMT field to register map and use it in RTL or clarify spec to make ROT_AMT fixed,Resolved - Spec v1.1 confirms ROT_AMT is fixed at 4 bits (intentional design),1.1